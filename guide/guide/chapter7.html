<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
                      "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
    <title>8 Page versioning and caching 6.x</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
    <link rel="stylesheet" href="../css/main.css" type="text/css" media="screen, print" title="Style" charset="utf-8"/>
    <link rel="stylesheet" href="../css/pdf.css" type="text/css" media="print" title="PDF" charset="utf-8"/>
    <script type="text/javascript">
function addJsClass() {
    var classes = document.body.className.split(" ");
    classes.push("js");
    document.body.className = classes.join(" ");
}
    </script>
</head>

<body class="body" onload="addJsClass();">
<div id="navigation">
    <ul>
        <li>
            <div id="nav-summary" onmouseover="toggleNavSummary(false)" onmouseout="toggleNavSummary(true)">
                <a href="../guide/index.html" class="button">Table of contents</a>

                <div id="nav-summary-childs" style="display:none;">
                    
                    <div class="toc-item" style="margin-left:0"><a href="../guide/chapter1.html"><strong>1</strong><span>Introduction</span></a>
                    </div>
                    
                    <div class="toc-item" style="margin-left:0"><a href="../guide/howToSource.html"><strong>2</strong><span>How to use the example code</span></a>
                    </div>
                    
                    <div class="toc-item" style="margin-left:0"><a href="../guide/chapter2.html"><strong>3</strong><span>Why should I learn Wicket?</span></a>
                    </div>
                    
                    <div class="toc-item" style="margin-left:0"><a href="../guide/chapter3.html"><strong>4</strong><span>Wicket says &ldquo;Hello world!&rdquo;</span></a>
                    </div>
                    
                    <div class="toc-item" style="margin-left:0"><a href="../guide/chapter4.html"><strong>5</strong><span>Wicket as page layout manager</span></a>
                    </div>
                    
                    <div class="toc-item" style="margin-left:0"><a href="../guide/chapter5.html"><strong>6</strong><span>Keeping control over HTML</span></a>
                    </div>
                    
                    <div class="toc-item" style="margin-left:0"><a href="../guide/chapter6.html"><strong>7</strong><span>Components lifecycle</span></a>
                    </div>
                    
                    <div class="toc-item" style="margin-left:0"><a href="../guide/chapter7.html"><strong>8</strong><span>Page versioning and caching</span></a>
                    </div>
                    
                    <div class="toc-item" style="margin-left:0"><a href="../guide/chapter8.html"><strong>9</strong><span>Under the hood of the request processing</span></a>
                    </div>
                    
                    <div class="toc-item" style="margin-left:0"><a href="../guide/chapter9.html"><strong>10</strong><span>Wicket Links and URL generation</span></a>
                    </div>
                    
                    <div class="toc-item" style="margin-left:0"><a href="../guide/chapter10.html"><strong>11</strong><span>Wicket models and forms</span></a>
                    </div>
                    
                    <div class="toc-item" style="margin-left:0"><a href="../guide/chapter11.html"><strong>12</strong><span>Wicket forms in detail</span></a>
                    </div>
                    
                    <div class="toc-item" style="margin-left:0"><a href="../guide/chapter12.html"><strong>13</strong><span>Displaying multiple items with repeaters</span></a>
                    </div>
                    
                    <div class="toc-item" style="margin-left:0"><a href="../guide/chapter13.html"><strong>14</strong><span>Internationalization with Wicket</span></a>
                    </div>
                    
                    <div class="toc-item" style="margin-left:0"><a href="../guide/chapter14.html"><strong>15</strong><span>Resource management with Wicket</span></a>
                    </div>
                    
                    <div class="toc-item" style="margin-left:0"><a href="../guide/chapter15.html"><strong>16</strong><span>An example of integration with JavaScript</span></a>
                    </div>
                    
                    <div class="toc-item" style="margin-left:0"><a href="../guide/chapter16.html"><strong>17</strong><span>Wicket advanced topics</span></a>
                    </div>
                    
                    <div class="toc-item" style="margin-left:0"><a href="../guide/chapter17.html"><strong>18</strong><span>Working with AJAX</span></a>
                    </div>
                    
                    <div class="toc-item" style="margin-left:0"><a href="../guide/chapter18.html"><strong>19</strong><span>Integration with enterprise containers</span></a>
                    </div>
                    
                    <div class="toc-item" style="margin-left:0"><a href="../guide/chapter19.html"><strong>20</strong><span>Security with Wicket</span></a>
                    </div>
                    
                    <div class="toc-item" style="margin-left:0"><a href="../guide/chapter20.html"><strong>21</strong><span>Test Driven Development with Wicket</span></a>
                    </div>
                    
                    <div class="toc-item" style="margin-left:0"><a href="../guide/chapter21.html"><strong>22</strong><span>Test Driven Development with Wicket and Spring</span></a>
                    </div>
                    
                    <div class="toc-item" style="margin-left:0"><a href="../guide/chapter22.html"><strong>23</strong><span>Wicket Best Practices</span></a>
                    </div>
                    
                    <div class="toc-item" style="margin-left:0"><a href="../guide/chapter23.html"><strong>24</strong><span>Working with Maven (Appendix)</span></a>
                    </div>
                    
                    <div class="toc-item" style="margin-left:0"><a href="../guide/chapter24.html"><strong>25</strong><span>Project WicketStuff (Appendix)</span></a>
                    </div>
                    
                    <div class="toc-item" style="margin-left:0"><a href="../guide/chapter25.html"><strong>26</strong><span>Lost In Redirection With Apache Wicket (Appendix)</span></a>
                    </div>
                    
                    <div class="toc-item" style="margin-left:0"><a href="../guide/chapter26.html"><strong>27</strong><span>Contributing to this guide (Appendix)</span></a>
                    </div>
                    
                </div>
            </div>
        </li>
        <li class="separator selected">
            <a id="ref-button" onclick="localToggle(); return false;" href="#">Quick Reference</a>
        </li>
    </ul>
</div>
<div id="header">
    <div class="images clearfix">
        
        <span id="logo"><a href="/" target="_blank"><img height="80px" src="http://wicket.apache.org/guide/img/apache-wicket.png"/></a></span>
        
        
        <span id="sponsor"><a href="http://www.apache.org/" target="_blank"><img height="60px" src="http://wicket.apache.org/guide/img/asf_logo.gif"/></a></span>
        
    </div>
    <p>Free Online Guide for Apache Wicket framework</p>
</div>


<table id="colset" border="0" cellpadding="0" cellspacing="0">
    <tr>
        <td id="col1">
            <div id="main" class="corner-all">

                
                    <div class="toc-item prev-left"><a href="../guide/chapter6.html">&lt;&lt; <strong>7</strong><span>Components lifecycle</span></a></div>
                

                <span id='toggle-col1' class="toggle">(<a href="#" onclick="localToggle(); return false;">Quick Reference</a>)</span>

                
                    <div class="toc-item next-right"><a href="../guide/chapter8.html"><strong>9</strong><span>Under the hood of the request processing</span> >></a></div>
                


                <div class="project">
                    <h1>8 Page versioning and caching - Reference Documentation</h1>

                    <p><strong>Authors:</strong> Andrea Del Bene, Carsten Hufe, Christian Kroemer, Daniel Bartl, Paul Borș</p>

                    <p><strong>Version:</strong> 6.x</p>

                    
                </div>

                
                <div id="table-of-content">
                    <h2>Table of Contents</h2>
                    
                    <div class="toc-item" style="margin-left:0px"><a href="#chapter7_1"><strong>8.1</strong><span>Stateful pages vs stateless</span></a>
                    </div>
                    
                    <div class="toc-item" style="margin-left:0px"><a href="#chapter7_2"><strong>8.2</strong><span>Stateful pages</span></a>
                    </div>
                    
                    <div class="toc-item" style="margin-left:0px"><a href="#chapter7_3"><strong>8.3</strong><span>Stateless pages</span></a>
                    </div>
                    
                    <div class="toc-item" style="margin-left:0px"><a href="#chapter7_4"><strong>8.4</strong><span>Summary</span></a>
                    </div>
                    
                </div>
                

                

<h1 id="chapter7">8 Page versioning and caching</h1>
This chapter explains how Wicket manages page instances, underlining the difference between stateful and stateless pages. The chapter also introduces some advanced topics like Java Serialization and multi-level cache. However, to understand what you will read you are not required to be familiar with these concepts.


<h2 id="chapter7_1">8.1 Stateful pages vs stateless</h2>
<p class="paragraph"/>Wicket pages can be divided into two categories: stateful and stateless pages. Stateful pages are those which rely on user session to store they internal state and to keep track of user interaction.
On the contrary stateless pages are those which don't change their internal state during their lifecycle and they don't need to occupy space into user session.<p class="paragraph"/>From Wicket's point of view the biggest difference between these two types of page is that stateful pages are versioned, meaning that they will be saved into user session every time their internal state has changed. Wicket automatically assigns a session to the user the first time a stateful page is requested. Page versions are stored into user session using Java Serialization mechanism. 
Stateless pages are never versioned and that's why they don't require a valid user session. If we want to know whether a page is stateless or not, we can call the isPageStateless() method of class Page.<p class="paragraph"/>In order to build a stateless page we must comply with some rules to ensure that the page won't need to use user session. These rules are illustrated in paragraph 6.3 but before talking about stateless pages we must first understand how stateful pages are handled and why they are versioned.


<h2 id="chapter7_2">8.2 Stateful pages</h2>
<p class="paragraph"/>Stateful pages are versioned in order to support browser's back button: when this button is pressed Wicket must respond by rendering the same page instance previously used.<p class="paragraph"/>A new page version is created when a stateful page is requested for the first time or when an existing instance is modified (for example changing its component hierarchy). To identify each page version Wicket uses a session-relative identifier called page id. This is a unique number and it is increased every time a new page version is created.<p class="paragraph"/>In the final example of the previous chapter (project LifeCycleStages), you may have noticed the number appended at the and of URL. This number is the page id we are talking about:<p class="paragraph"/><img border="0" class="center" src="../img/page-id.png"></img><p class="paragraph"/>In this chapter we will use a revised version of this example project where the component hierarchy is modified inside the Link's onClick()method. This is necessary because Wicket creates a new page version only if the page is modified before its method onBeforeRender() is invoked. The code of the new home page is the following:<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">public</span> class HomePage <span class="java&#45;keyword">extends</span> WebPage
&#123;
	<span class="java&#45;keyword">private</span> <span class="java&#45;keyword">static</span> <span class="java&#45;keyword">final</span> <span class="java&#45;object">long</span> serialVersionUID = 1L;
	<span class="java&#45;keyword">private</span> Label firstLabel;
	<span class="java&#45;keyword">private</span> Label secondLabel;<p class="paragraph"/>	<span class="java&#45;keyword">public</span> HomePage()&#123;
		firstLabel = <span class="java&#45;keyword">new</span> Label(<span class="java&#45;quote">"label"</span>, <span class="java&#45;quote">"First label"</span>);
		secondLabel = <span class="java&#45;keyword">new</span> Label(<span class="java&#45;quote">"label"</span>, <span class="java&#45;quote">"Second label"</span>);<p class="paragraph"/>		add(firstLabel);<p class="paragraph"/>		add(<span class="java&#45;keyword">new</span> Link(<span class="java&#45;quote">"reload"</span>)&#123;
			@Override
			<span class="java&#45;keyword">public</span> void onClick() &#123;				
				<span class="java&#45;keyword">if</span>(getPage().contains(firstLabel, <span class="java&#45;keyword">true</span>))
					getPage().replace(secondLabel);
				<span class="java&#45;keyword">else</span>
					getPage().replace(firstLabel);		
			&#125;
		&#125;);<p class="paragraph"/>	&#125;	
&#125;</pre></div><p class="paragraph"/>Now if we run the new example (project LifeCycleStagesRevisited) and we click on the “Reload” button, a new page version is created and the page id is increased by one:<p class="paragraph"/><img border="0" class="center" src="../img/reload-page.png"></img><p class="paragraph"/>If we press the back button the page version previously rendered (and serialized) will be retrieved (i.e. deserialized) and it will be used again to respond to our request (and page id is decremented):<p class="paragraph"/><img border="0" class="center" src="../img/browser-back.png"></img><p class="paragraph"/><blockquote class="note">
For more details about page storing you can visit the wiki page at https://cwiki.apache.org/confluence/display/WICKET/Page+Storage . 
On this page you can find which classes are involved into page storing mechanism and how they work together.
</blockquote><p class="paragraph"/>As we have stated at the beginning of this chapter, page versions are stored using Java serialization, therefore every object referenced inside a page must be serializable1. In paragraph 9.6 we will see how to overcome this limit and work with non-serializable objects in our components using detachable Wicket models.<p class="paragraph"/><h3>Using a specific page version with PageReference</h3><p class="paragraph"/>To retrieve a specific page version in our code we can use class <code>org.apache.wicket.PageReference</code> by providing its constructor with the corresponding page id:<p class="paragraph"/><div class="code"><pre>//load page version with page id = 3
PageReference pageReference = <span class="java&#45;keyword">new</span> PageReference(3);
//load the related page instance
Page page = pageReference.getPage();</pre></div><p class="paragraph"/>To get the related page instance we must use method getPage.<p class="paragraph"/><h3>Turning off page versioning</h3><p class="paragraph"/>If for any reason we need to switch off versioning for a given page, we can call its method setVersioned(false).<p class="paragraph"/><h3>Pluggable serialization</h3><p class="paragraph"/>Starting from version 1.5 it is possible to choose which implementation of Java serialization will be used by Wicket to store page versions. Wicket serializes pages using an implementation of interface <code>org.apache.wicket.serialize.ISerializer</code>. The default implementation is <code>org.apache.wicket.serialize.java.JavaSerializer</code> and it uses the standard Java serialization mechanism based on classes ObjectOutputStream and ObjectInputStream. However on Internet we can find other interesting serialization libraries like Kryo1 which performs faster then the standard implementation.The serializer in use can be customized with the setSerializer(ISerializer) method defined by setting interface <code>org.apache.wicket.settings.IFrameworkSettings</code>.<p class="paragraph"/>We can access this interface inside the method init of the class Application using the getFrameworkSettings() method :<p class="paragraph"/><div class="code"><pre>@Override
<span class="java&#45;keyword">public</span> void init()
&#123;
	<span class="java&#45;keyword">super</span>.init();
	getFrameworkSettings().setSerializer(yourSerializer);
&#125;</pre></div><p class="paragraph"/>A serializer based on Kryo library is provided by the WicketStuff project. You can find more information on this project, as well as the instructions to use its modules, in Appendix B.<p class="paragraph"/><h3>Page caching</h3><p class="paragraph"/>By default Wicket persists versions of pages into a session-relative file on disk, but it uses a two-levels cache to speed up this process. The first level of the cache uses a http session attribute called “wicket:persistentPageManagerData-&#60;APPLICATION_NAME&#62;” to store pages. The second level cache stores pages into application-scoped variables which are identified by a session id and a page id.<p class="paragraph"/>The following picture is an overview of these two caching levels:<p class="paragraph"/><img border="0" class="center" src="../img/wicket-cache.png"></img><p class="paragraph"/>The session-scoped cache is faster then the other memory levels but it contains only the pages used to serve the last request. Wicket allows us to set the maximum amount of memory allowed for the application-scoped cache and for the page store file. Both parameters can be configured via setting interface <code>org.apache.wicket.settings.IStoreSettings</code>.<p class="paragraph"/>This interface provides the setMaxSizePerSession(Bytes bytes) method to set the size for page store file. The Bytes parameter is the maximum size allowed for this file:<p class="paragraph"/><div class="code"><pre>@Override
<span class="java&#45;keyword">public</span> void init()
&#123;
	<span class="java&#45;keyword">super</span>.init();
	getStoreSettings().setMaxSizePerSession(Bytes.kilobytes(500));
&#125;</pre></div><p class="paragraph"/>Class <code>org.apache.wicket.util.lang.Bytes</code> is an utility class provided by Wicket to express size in bytes (for further details refer to the JavaDoc).
For the second level cache we can use the setInmemoryCacheSize(int inmemoryCacheSize) method. The integer parameter is the maximum number of page instances that will be saved into application-scoped cache:<p class="paragraph"/><div class="code"><pre>@Override
<span class="java&#45;keyword">public</span> void init()
&#123;
	<span class="java&#45;keyword">super</span>.init();
	getStoreSettings().setInmemoryCacheSize(50);
&#125;</pre></div><p class="paragraph"/><h3>Page expiration</h3><p class="paragraph"/>Page instances are not kept in the user session forever. They can be discarded when the limit set with the setMaxSizePerSession method is reached or (more often) when user session expires. When we ask Wicket for a page id corresponding to a page instance removed from the session, we bump into a  PageExpiredException and we get the following default error page:<p class="paragraph"/><img border="0" class="center" src="../img/page-expired.png"></img><p class="paragraph"/>This error page can be customized with the setPageExpiredErrorPage method of the <code>org.apache.wicket.settings.IApplicationSettings</code> interface:<p class="paragraph"/><div class="code"><pre>@Override
<span class="java&#45;keyword">public</span> void init()
&#123;
	<span class="java&#45;keyword">super</span>.init();
	getApplicationSettings().setPageExpiredErrorPage(
				CustomExpiredErrorPage.class);
&#125;</pre></div><p class="paragraph"/>The page class provided as custom error page must have a public constructor with no argument or a constructor that takes as input a single PageParameters argument (the page must be bookmarkable as described in paragraph 8.1.1).



<h2 id="chapter7_3">8.3 Stateless pages</h2>
<p class="paragraph"/>Wicket makes it very easy to build stateful pages, but sometimes we might want to use an “old school” stateless page that doesn't keep memory of its state in the user session. For example consider the public area of a site or a login page: in those cases a stateful page would be a waste of resources or even a security threat, as we will see in paragraph 10.9.<p class="paragraph"/>In Wicket a page can be stateless only if it satisfies the following requirements:
<ol>
<li>it has been instantiated by Wicket (i.e. we don't create it with operator new) using a constructor with no argument or a constructor that takes as input a single PageParameters argument (class PageParameters will be covered in chapter 8).</li>
<li>All its children components (and behaviors) are in turn stateless, which means that their method isStateless must return true.</li>
</ol><p class="paragraph"/>The first requirement implies that, rather than creating a page by hand, we should rely on Wicket's capability of resolving page instances, like we do when we use method setResponsePage(Class page).<p class="paragraph"/>In order to comply with the second requirement it could be helpful to check if all children components of a page are stateless. To do this we can leverage method visitChildren and the visitor pattern to iterate over components and test if their method isStateless actually returns true:<p class="paragraph"/><div class="code"><pre>@Override
<span class="java&#45;keyword">protected</span> void onInitialize() &#123;
		<span class="java&#45;keyword">super</span>.onInitialize();<p class="paragraph"/>		visitChildren(<span class="java&#45;keyword">new</span> IVisitor&#60;Component, <span class="java&#45;object">Void</span>&#62;() &#123;
			@Override
			<span class="java&#45;keyword">public</span> void component(Component component, IVisit&#60;<span class="java&#45;object">Void</span>&#62; arg1) &#123;
				<span class="java&#45;keyword">if</span>(!component.isStateless())
		  			<span class="java&#45;object">System</span>.out.println(<span class="java&#45;quote">"Component "</span> + component.getId() + <span class="java&#45;quote">" is not stateless"</span>);
			&#125;
		&#125;);
	&#125;</pre></div><p class="paragraph"/>Alternatively, we could use the <code>StatelessComponent</code> utility annotation along with the <code>StatelessChecker</code> class (they are both in package <code>org.apache.wicket.devutils.stateless</code>). <code>StatelessChecker</code> will throw an <code>IllegalArgumentException</code> if a component annotated with <code>StatelessComponent</code> doesn't respect the requirements for being stateless. To use <code>StatelessComponent</code> annotation we must first add the <code>StatelessChecker</code> to our application as a component render listener:<p class="paragraph"/><div class="code"><pre>@Override
<span class="java&#45;keyword">public</span> void init()
&#123;
	<span class="java&#45;keyword">super</span>.init();
	getComponentPostOnBeforeRenderListeners().add(<span class="java&#45;keyword">new</span> StatelessChecker());
&#125;</pre></div><p class="paragraph"/><blockquote class="note">
Most of the Wicket's built-in components are stateful, hence they can not be used with a stateless page. However some of them have also a stateless version which can be adopted when we need to keep a page stateless. In the rest of the guide we will point out when a built-in component comes also with a stateless version.
</blockquote><p class="paragraph"/>A page can be also explicitly declared as stateless setting the appropriate flag to true with the setStatelessHint(true) method. This method will not prevent us from violating the requirements for a stateless page, but if we do so we will get the following warning log message:<p class="paragraph"/><blockquote class="warning">
Page '&#60;page class&#62;' is not stateless because of component with path '&#60;component path&#62;'
</blockquote>



<h2 id="chapter7_4">8.4 Summary</h2>
<p class="paragraph"/>In this chapter we have seen how page instances are managed by Wicket. We have learnt that pages can be divided into two families: stateless and stateful pages. Knowing the difference between the two types of pages is important to build the right page for a given task.<p class="paragraph"/>However, to complete the discussion about stateless pages we still have to deal with two topics we have just outlined in this chapter: class PageParameters and bookmarkable pages. The first part of chapter 8 will cover these missing topics.


                <div style="clear:both;margin-top:15px;"></div>
                
                    <div class="toc-item prev-left"><a href="../guide/chapter6.html">&lt;&lt; <strong>7</strong><span>Components lifecycle</span></a></div>
                
                    <div class="toc-item next-right"><a href="../guide/chapter8.html"><strong>9</strong><span>Under the hood of the request processing</span> >></a></div>
                
                <div style="clear:both"></div>
            </div>
        </td>
        <td id="col2">
            <div class="local clearfix">
                <div class="local-title">
                    <a href="../guide/index.html" target="mainFrame">Quick Reference</a>
                    <span class="toggle">(<a href="#" onclick="localToggle(); return false;">hide</a>)</span>
                </div>
                <div class="menu">
                    
                </div>
            </div>
        </td>
    </tr>
</table>

<div id="footer">
    
Copyright &copy; 2013 — <a href="http://www.apache.org/" target="_blank">The Apache Software Foundation</a>

    
</div>

<script type="text/javascript" src="../js/docs.js"></script>

</body>
</html>
