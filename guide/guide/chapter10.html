<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
                      "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
    <title>10 Wicket models and forms 1.0.0.BUILD-SNAPSHOT</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
    <link rel="stylesheet" href="../css/main.css" type="text/css" media="screen, print" title="Style" charset="utf-8"/>
    <link rel="stylesheet" href="../css/pdf.css" type="text/css" media="print" title="PDF" charset="utf-8"/>
    <script type="text/javascript">
function addJsClass() {
    var classes = document.body.className.split(" ");
    classes.push("js");
    document.body.className = classes.join(" ");
}
    </script>
</head>

<body class="body" onload="addJsClass();">
<div id="navigation">
    <ul>
        <li>
            <div id="nav-summary" onmouseover="toggleNavSummary(false)" onmouseout="toggleNavSummary(true)">
                <a href="../guide/index.html" class="button">Table of contents</a>

                <div id="nav-summary-childs" style="display:none;">
                    
                    <div class="toc-item" style="margin-left:0"><a href="../guide/chapter1.html"><strong>1</strong><span>Introduction</span></a>
                    </div>
                    
                    <div class="toc-item" style="margin-left:0"><a href="../guide/chapter2.html"><strong>2</strong><span>Why should I learn Wicket?</span></a>
                    </div>
                    
                    <div class="toc-item" style="margin-left:0"><a href="../guide/chapter3.html"><strong>3</strong><span>Wicket says &ldquo;Hello world!&rdquo;</span></a>
                    </div>
                    
                    <div class="toc-item" style="margin-left:0"><a href="../guide/chapter4.html"><strong>4</strong><span>Wicket as page layout manager</span></a>
                    </div>
                    
                    <div class="toc-item" style="margin-left:0"><a href="../guide/chapter5.html"><strong>5</strong><span>Keeping control over HTML</span></a>
                    </div>
                    
                    <div class="toc-item" style="margin-left:0"><a href="../guide/chapter6.html"><strong>6</strong><span>Components lifecycle</span></a>
                    </div>
                    
                    <div class="toc-item" style="margin-left:0"><a href="../guide/chapter7.html"><strong>7</strong><span>Page versioning and caching</span></a>
                    </div>
                    
                    <div class="toc-item" style="margin-left:0"><a href="../guide/chapter8.html"><strong>8</strong><span>Under the hood of the request processing</span></a>
                    </div>
                    
                    <div class="toc-item" style="margin-left:0"><a href="../guide/chapter9.html"><strong>9</strong><span>Wicket Links and URL generation</span></a>
                    </div>
                    
                    <div class="toc-item" style="margin-left:0"><a href="../guide/chapter10.html"><strong>10</strong><span>Wicket models and forms</span></a>
                    </div>
                    
                    <div class="toc-item" style="margin-left:0"><a href="../guide/chapter11.html"><strong>11</strong><span>Wicket forms in detail</span></a>
                    </div>
                    
                    <div class="toc-item" style="margin-left:0"><a href="../guide/chapter12.html"><strong>12</strong><span>Displaying multiple items with repeaters</span></a>
                    </div>
                    
                    <div class="toc-item" style="margin-left:0"><a href="../guide/chapter13.html"><strong>13</strong><span>Internationalization with Wicket</span></a>
                    </div>
                    
                    <div class="toc-item" style="margin-left:0"><a href="../guide/chapter14.html"><strong>14</strong><span>Resource management with Wicket</span></a>
                    </div>
                    
                    <div class="toc-item" style="margin-left:0"><a href="../guide/chapter15.html"><strong>15</strong><span>An example of integration with JavaScript</span></a>
                    </div>
                    
                    <div class="toc-item" style="margin-left:0"><a href="../guide/chapter16.html"><strong>16</strong><span>Wicket advanced topics</span></a>
                    </div>
                    
                    <div class="toc-item" style="margin-left:0"><a href="../guide/chapter17.html"><strong>17</strong><span>Working with AJAX</span></a>
                    </div>
                    
                    <div class="toc-item" style="margin-left:0"><a href="../guide/chapter18.html"><strong>18</strong><span>Integration with enterprise containers</span></a>
                    </div>
                    
                    <div class="toc-item" style="margin-left:0"><a href="../guide/chapter19.html"><strong>19</strong><span>Security with Wicket</span></a>
                    </div>
                    
                    <div class="toc-item" style="margin-left:0"><a href="../guide/chapter20.html"><strong>20</strong><span>Test Driven Development with Wicket</span></a>
                    </div>
                    
                    <div class="toc-item" style="margin-left:0"><a href="../guide/chapter21.html"><strong>21</strong><span>Test Driven Development with Wicket and Spring</span></a>
                    </div>
                    
                    <div class="toc-item" style="margin-left:0"><a href="../guide/chapter22.html"><strong>22</strong><span>Wicket Best Practices</span></a>
                    </div>
                    
                    <div class="toc-item" style="margin-left:0"><a href="../guide/chapter23.html"><strong>23</strong><span>Working with Maven (Appendix)</span></a>
                    </div>
                    
                    <div class="toc-item" style="margin-left:0"><a href="../guide/chapter24.html"><strong>24</strong><span>Project WicketStuff (Appendix)</span></a>
                    </div>
                    
                    <div class="toc-item" style="margin-left:0"><a href="../guide/chapter25.html"><strong>25</strong><span>Lost In Redirection With Apache Wicket (Appendix)</span></a>
                    </div>
                    
                </div>
            </div>
        </li>
        <li class="separator selected">
            <a id="ref-button" onclick="localToggle(); return false;" href="#">Quick Reference</a>
        </li>
    </ul>
</div>
<div id="header">
    <div class="images clearfix">
        
        <span id="logo"><a href="/" target="_blank"><img height="80px" src="http://comsysto.github.io/wicket-userguide/img/apache-wicket.png"/></a></span>
        
        
        <span id="sponsor"><a href="http://www.comsysto.com/" target="_blank"><img height="60px" src="http://comsysto.github.io/wicket-userguide/img/comsysto-logo.png"/></a></span>
        
    </div>
    <p>Free Online Guide for Apache Wicket framework</p>
</div>


<table id="colset" border="0" cellpadding="0" cellspacing="0">
    <tr>
        <td id="col1">
            <div id="main" class="corner-all">

                
                    <div class="toc-item prev-left"><a href="../guide/chapter9.html">&lt;&lt; <strong>9</strong><span>Wicket Links and URL generation</span></a></div>
                

                <span id='toggle-col1' class="toggle">(<a href="#" onclick="localToggle(); return false;">Quick Reference</a>)</span>

                
                    <div class="toc-item next-right"><a href="../guide/chapter11.html"><strong>11</strong><span>Wicket forms in detail</span> >></a></div>
                


                <div class="project">
                    <h1>10 Wicket models and forms - Reference Documentation</h1>

                    <p><strong>Authors:</strong> Andrea Del Bene, Carsten Hufe, Christian Kroemer, Daniel Bartl</p>

                    <p><strong>Version:</strong> 1.0.0.BUILD-SNAPSHOT</p>

                    
                </div>

                
                <div id="table-of-content">
                    <h2>Table of Contents</h2>
                    
                    <div class="toc-item" style="margin-left:0px"><a href="#chapter10_1"><strong>10.1</strong><span>What is a model?</span></a>
                    </div>
                    
                    <div class="toc-item" style="margin-left:0px"><a href="#chapter10_2"><strong>10.2</strong><span>Models and JavaBeans</span></a>
                    </div>
                    
                    <div class="toc-item" style="margin-left:0px"><a href="#chapter10_3"><strong>10.3</strong><span>Wicket forms</span></a>
                    </div>
                    
                    <div class="toc-item" style="margin-left:0px"><a href="#chapter10_4"><strong>10.4</strong><span>Component DropDownChoice</span></a>
                    </div>
                    
                    <div class="toc-item" style="margin-left:0px"><a href="#chapter10_5"><strong>10.5</strong><span>Model chaining</span></a>
                    </div>
                    
                    <div class="toc-item" style="margin-left:0px"><a href="#chapter10_6"><strong>10.6</strong><span>Detachable models</span></a>
                    </div>
                    
                    <div class="toc-item" style="margin-left:0px"><a href="#chapter10_7"><strong>10.7</strong><span>Using more than one model in a component</span></a>
                    </div>
                    
                    <div class="toc-item" style="margin-left:0px"><a href="#chapter10_8"><strong>10.8</strong><span>Use models!</span></a>
                    </div>
                    
                    <div class="toc-item" style="margin-left:0px"><a href="#chapter10_9"><strong>10.9</strong><span>Summary</span></a>
                    </div>
                    
                </div>
                

                

<h1 id="chapter10">10 Wicket models and forms</h1>
In Wicket the concept of “model” is probably the most important topic of the entire framework and it is strictly related to the usage of its components. In addition, models are also an important element for  internationalization, as we will see in paragraph 12.6. However, despite their fundamental role, in Wicket models are not difficult to understand but the best way to learn how they work is to use them with forms. That's why we haven't talked about models so far, and why this chapter discusses these two topics together.


<h2 id="chapter10_1">10.1 What is a model?</h2>
<p class="paragraph"/>Model is essentially a <a href="http://en.wikipedia.org/wiki/Facade_pattern" target="blank">facade</a> interface which allows components to access and modify their data without knowing any detail about how they are managed or persisted. Every component has at most one related model, while a model can be shared among different components. In Wicket a model is any implementation of the interface org.apache.wicket.model.IModel:<p class="paragraph"/><img border="0" class="center" src="../img/uml-imodel.png"></img><p class="paragraph"/>The IModel interface defines just the methods needed to get and set a data object (getObject() and setObject()), decoupling components from concrete details about the persistence strategy adopted for data. In addition, the level of indirection introduced by models allows access data object only when it is really needed (for example during the rendering phase) and not earlier when it may not be ready to be used.<p class="paragraph"/>Any component can get/set its model as well as its data object using the 4 public shortcut methods listed in the class diagram above. The two methods onModelChanged() and onModelChanging() are triggered by Wicket each time a model is modified: the first one is called after the model has been changed, the second one just before the change occurs. In the examples seen so far we have worked with Label component using its constructor which takes as input two string parameters, the component id and the text to display:<p class="paragraph"/><div class="code"><pre>add(<span class="java&#45;keyword">new</span> Label(<span class="java&#45;quote">"helloMessage"</span>, <span class="java&#45;quote">"Hello WicketWorld!"</span>));</pre></div><p class="paragraph"/>This constructor internally builds a model which wraps the second string parameter. That's why we didn't mention label model in the previous examples. Here is the code of this constructor:<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">public</span> Label(<span class="java&#45;keyword">final</span> <span class="java&#45;object">String</span> id, <span class="java&#45;object">String</span> label) &#123;
	<span class="java&#45;keyword">this</span>(id, <span class="java&#45;keyword">new</span> Model&#60;<span class="java&#45;object">String</span>&#62;(label));
&#125;</pre></div><p class="paragraph"/>Class org.apache.wicket.model.Model is a basic implementation of IModel. It can wrap any object that implements the interface java.io.Serializable. The reason of this constraint over data object is that this model is stored in the web session, and we know from chapter 6 that data are stored into session using serialization.<p class="paragraph"/><blockquote class="note">
In general, Wicket models support a detaching capability that allows us to work also with non-serializable objects as data model. We will see the detaching mechanism later in this chapter.
</blockquote><p class="paragraph"/>Just like any other Wicket components, Label provides a constructor that takes as input the component id and the model to use with the component. Using this constructor the previous example becomes:<p class="paragraph"/><div class="code"><pre>add(<span class="java&#45;keyword">new</span> Label(<span class="java&#45;quote">"helloMessage"</span>, <span class="java&#45;keyword">new</span> Model&#60;<span class="java&#45;object">String</span>&#62;(<span class="java&#45;quote">"Hello WicketWorld!"</span>)));</pre></div><p class="paragraph"/><blockquote class="note">
The Model class comes with a bunch of factory methods that makes it easier to build new model instances. For example the of(T object) method creates a new instance of Model which wraps any Object instance inside it. So instead of writing<p class="paragraph"/>	new Model&#60;String&#62;("Hello WicketWorld!")<p class="paragraph"/>we can write<p class="paragraph"/>	Model.of("Hello WicketWorld!")<p class="paragraph"/>If the data object is a List, a Map or a Set we can use similar methods called ofList, ofMap and ofSet.   
From now on we will use these factory methods in our examples.
</blockquote><p class="paragraph"/>It's quite clear that if our Label must display a static text it doesn't make much sense to build a model by hand like we did in the last code example.
However is not unusual to have a Label that must display a dynamic value, like the input provided by a user or a value read from a database. Wicket models are designed to solve these kinds of problems.<p class="paragraph"/>Let's say we need a label to display the current time stamp each time a page is rendered. We can implement a custom model which returns a new Date instance when the getObject() method is called:<p class="paragraph"/><div class="code"><pre>IModel timeStampModel = <span class="java&#45;keyword">new</span> Model&#60;<span class="java&#45;object">String</span>&#62;()&#123;
	@Override
	<span class="java&#45;keyword">public</span> <span class="java&#45;object">String</span> getObject() &#123;
		<span class="java&#45;keyword">return</span> <span class="java&#45;keyword">new</span> Date().toString();
	&#125;
&#125;;<p class="paragraph"/>add(<span class="java&#45;keyword">new</span> Label(<span class="java&#45;quote">"timeStamp"</span>, timeStampModel));</pre></div><p class="paragraph"/>Even if sometimes writing a custom model could be a good choice to solve a specific problem, Wicket already provides a set of IModel implementations which should fit most of our needs. In the next paragraph we will see a couple of models that allow us to easily integrate JavaBeans with our web applications and in particular with our forms.<p class="paragraph"/><blockquote class="note">
By default class Component escapes HTML sensitive characters (like '&#60;', '&#62;' or '&#38;') from the textual representation of its model object. The term 'escape' means that these characters will be replaced with their corresponding HTML <a href="http://en.wikipedia.org/wiki/Character_entity_reference" target="blank">entity</a> (for example '&#60;' becomes '&#38;lt; '). This is done for security reasons as a malicious user could attempt to inject markup or JavaScript into our pages. If we want to display the raw content stored inside a model, we can tell the Component class not to escape characters by calling the setEscape ModelStrings(false) method.
</blockquote>


<h2 id="chapter10_2">10.2 Models and JavaBeans</h2>
<p class="paragraph"/>One of the main goals of Wicket is to use JavaBeans and POJO as data model, overcoming the impedance mismatch between web technologies and OO paradigm. In order to make this task as easy as possible, Wicket offers two special model classes: org.apache.wicket.model.PropertyModel and org.apache.wicket.model.CompoundPropertyModel. We will see how to use them in the next two examples, using the following JavaBean as the data object:<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">public</span> class Person <span class="java&#45;keyword">implements</span> Serializable &#123;<p class="paragraph"/>	<span class="java&#45;keyword">private</span> <span class="java&#45;object">String</span> name;
	<span class="java&#45;keyword">private</span> <span class="java&#45;object">String</span> surname;
	<span class="java&#45;keyword">private</span> <span class="java&#45;object">String</span> address;
	<span class="java&#45;keyword">private</span> <span class="java&#45;object">String</span> email;
	<span class="java&#45;keyword">private</span> <span class="java&#45;object">String</span> passportCode;<p class="paragraph"/>	<span class="java&#45;keyword">private</span> Person spouse;
	<span class="java&#45;keyword">private</span> List&#60;Person&#62; children;<p class="paragraph"/>	<span class="java&#45;keyword">public</span> Person(<span class="java&#45;object">String</span> name, <span class="java&#45;object">String</span> surname) &#123;
		<span class="java&#45;keyword">this</span>.name = name;
		<span class="java&#45;keyword">this</span>.surname = surname;
	&#125;<p class="paragraph"/>	<span class="java&#45;keyword">public</span> <span class="java&#45;object">String</span> getFullName()&#123;
   		<span class="java&#45;keyword">return</span> name + <span class="java&#45;quote">" "</span> + surname;
	&#125;<p class="paragraph"/>	/&#42; 	 
	 &#42; Getters and setters <span class="java&#45;keyword">for</span> <span class="java&#45;keyword">private</span> fields
     &#42;/
&#125;</pre></div><p class="paragraph"/><h3>PropertyModel</h3><p class="paragraph"/>Let's say we want to display the name field of a Person instance with a label. We could, of course, use the Model class like we did in the previous example, obtaining something like this:<p class="paragraph"/><div class="code"><pre>Person person = <span class="java&#45;keyword">new</span> Person();		
//load person's data...<p class="paragraph"/>Label label = <span class="java&#45;keyword">new</span> Label(<span class="java&#45;quote">"name"</span>, <span class="java&#45;keyword">new</span> Model(person.getName()));</pre></div><p class="paragraph"/>However this solution has a huge drawback: the text displayed by the label will be static and if we change the value of the field, the label won't update its content. Instead, to always display the current value of a class field, we should use the org.apache.wicket.model.PropertyModel model class:<p class="paragraph"/><div class="code"><pre>Person person = <span class="java&#45;keyword">new</span> Person();		
//load person's data...<p class="paragraph"/>Label label = <span class="java&#45;keyword">new</span> Label(<span class="java&#45;quote">"name"</span>, <span class="java&#45;keyword">new</span> PropertyModel(person, <span class="java&#45;quote">"name"</span>));</pre></div><p class="paragraph"/>PropertyModel has just one constructor with two parameters: the model object (person in our example) and the name of the property we want to read/write ("name" in our example). This last parameter is called property expression. Internally, methods getObject/setObject use property expression to get/set property's value. To resolve class properties PropertyModel uses class org.apache.wicket.util.lang.Property Resolver which can access any kind of property, private fields included.<p class="paragraph"/>Just like the Java language, property expressions support dotted notation to select sub properties. So if we want to display the name of the Person's spouse we can write:<p class="paragraph"/><div class="code"><pre>Label label = <span class="java&#45;keyword">new</span> Label(<span class="java&#45;quote">"spouseName"</span>, <span class="java&#45;keyword">new</span> PropertyModel(person, <span class="java&#45;quote">"spouse.name"</span>));</pre></div><p class="paragraph"/><blockquote class="note">
PropertyModel is null-safe, which means we don't have to worry if property expression includes a null value in its path. If such a value is encountered, an empty string will be returned.
</blockquote><p class="paragraph"/>If property is an array or a List, we can specify an index after its name. For example, to display the name of the first child of a Person we can write the following property expression:<p class="paragraph"/><div class="code"><pre>Label label = <span class="java&#45;keyword">new</span> Label(<span class="java&#45;quote">"firstChildName"</span>, <span class="java&#45;keyword">new</span> PropertyModel(person, <span class="java&#45;quote">"children.0.name"</span>));</pre></div><p class="paragraph"/>Indexes and map keys can be also specified using squared brackets like “children0.name” or “mapFieldkey.subfield”.<p class="paragraph"/><h3>CompoundPropertyModel and model inheritance</h3><p class="paragraph"/>Class org.apache.wicket.model.CompoundPropertyModel is a particular kind of model which is usually used in conjunction with another Wicket feature called model inheritance. With this feature, when a component needs to use a model but none has been assigned to it, it will search through the whole container hierarchy for a parent with an inheritable model. Inheritable models are those which implement interface org.apache.wicket.model.IComponentInheritedModel and CompoundPropertyModel is one of them. Once a CompoundPropertyModel has been inherited by a component, it will behave just like a PropertyModel using the id of the component as property expression. As a consequence, to make the most of CompoundPropertyModel we must assign it to one of the containers of a given component, rather than directly to the component itself.<p class="paragraph"/>For example if we use CompoundPropertyModel with the previous example (display spouse's name), the code would become like this:<p class="paragraph"/><div class="code"><pre>//set CompoundPropertyModel as model <span class="java&#45;keyword">for</span> the container of the label
setDefaultModel(<span class="java&#45;keyword">new</span> CompoundPropertyModel(person));<p class="paragraph"/>Label label = <span class="java&#45;keyword">new</span> Label(<span class="java&#45;quote">"spouse.name"</span>);<p class="paragraph"/>add(label);</pre></div><p class="paragraph"/>Note that now the id of the label is equal to the property expression previously used with PropertyModel. Now as a further example let's say we want to extend the code above to display all of the main informations of a person (name, surname, address and email). All we have to do is to add one label for every additional information using the relative property expression as component id:<p class="paragraph"/><div class="code"><pre>//Create a person named 'John Smith'
Person person = <span class="java&#45;keyword">new</span> Person(<span class="java&#45;quote">"John"</span>, <span class="java&#45;quote">"Smith"</span>);
setDefaultModel(<span class="java&#45;keyword">new</span> CompoundPropertyModel(person));<p class="paragraph"/>add(<span class="java&#45;keyword">new</span> Label(<span class="java&#45;quote">"name"</span>));
add(<span class="java&#45;keyword">new</span> Label(<span class="java&#45;quote">"surname"</span>));
add(<span class="java&#45;keyword">new</span> Label(<span class="java&#45;quote">"address"</span>));
add(<span class="java&#45;keyword">new</span> Label(<span class="java&#45;quote">"email"</span>));
add(<span class="java&#45;keyword">new</span> Label(<span class="java&#45;quote">"spouse.name"</span>));</pre></div><p class="paragraph"/>CompoundPropertyModel can save us a lot of boring coding if we choose the id of components according to properties name. However it's also possible to use this type of model even if the id of a component does not correspond to a valid property expression. The method bind(String property) allows to create a property model from a given CompoundPropertyModel using the provided parameter as property expression. For example if we want to display the spouse's name in a label having "xyz" as id, we can write the following code:<p class="paragraph"/><div class="code"><pre>//Create a person named 'John Smith'
Person person = <span class="java&#45;keyword">new</span> Person(<span class="java&#45;quote">"John"</span>, <span class="java&#45;quote">"Smith"</span>);
CompoundPropertyModel compoundModel;
setDefaultModel(compoundModel = <span class="java&#45;keyword">new</span> CompoundPropertyModel(person));<p class="paragraph"/>add(<span class="java&#45;keyword">new</span> Label(<span class="java&#45;quote">"xyz"</span>, compoundModel.bind(<span class="java&#45;quote">"spouse.name"</span>)));</pre></div><p class="paragraph"/>CompoundPropertyModel are particularly useful when used in combination with Wicket forms, as we will see in the next paragraph.<p class="paragraph"/><blockquote class="note">
Model is referred to as static model because the result of its method getObject is fixed an it is not dynamically evaluated each time the method is called. In contrast, models like PropertyModel and CompoundProperty Model are called dynamic models.
</blockquote>


<h2 id="chapter10_3">10.3 Wicket forms</h2>
<p class="paragraph"/>Web applications use HTML forms to collect user input and send it to the server. Wicket provides org.apache.wicket.markup.html.form.Form class to handle web forms. This component must be bound to &#60;form&#62; tag. The following snippet shows how to create a very basic Wicket form in a page:<p class="paragraph"/>Html:<p class="paragraph"/><div class="code"><pre>&#60;form wicket:id=<span class="java&#45;quote">"form"</span>&#62;
    &#60;input type=<span class="java&#45;quote">"submit"</span> value=<span class="java&#45;quote">"submit"</span>/&#62;
&#60;/form&#62;</pre></div><p class="paragraph"/>
Java code:<p class="paragraph"/><div class="code"><pre>Form form = <span class="java&#45;keyword">new</span> Form(<span class="java&#45;quote">"form"</span>)&#123;
    @Override
    <span class="java&#45;keyword">protected</span> void onSubmit() &#123;
    	<span class="java&#45;object">System</span>.out.println(<span class="java&#45;quote">"Form submitted."</span>);
    &#125;
&#125;;
add(form);</pre></div><p class="paragraph"/>Method onSubmit is called whenever a form has been submitted and it can be overridden to perform custom actions. Please note that a Wicket form can be submitted using a standard HTML submit button which is not mapped to any component (i.e. it does not have a wicket:id attribute). 
In the next chapter we will continue to explore Wicket forms and we will see how to submit forms using special components which implement interface org.apache.wicket.markup.html.form.IFormSubmitter.<p class="paragraph"/><h3>Form and models</h3><p class="paragraph"/>A form should contain some input fields (like text fields, check boxes, radio buttons, drop-down lists, text areas, etc.) to interact with users. Wicket provides an abstraction for all these kinds of elements with component org.apache.wicket.markup.html.form.FormComponent:<p class="paragraph"/><img border="0" class="center" src="../img/uml-form-component.png"></img><p class="paragraph"/>The purpose of FormComponent is to store the corresponding user input into its model when the form is submitted. The form is responsible for mapping input values to the corresponding components, avoiding us the burden of manually synchronizing models with input fields and vice versa.<p class="paragraph"/><h3>Login form</h3><p class="paragraph"/>As first example of interaction between the form and its models, we will build a classic login form which asks for username and password (project LoginForm).<p class="paragraph"/><blockquote class="warning">
The topic of security will be discussed later in chapter 18. The following form is for example purposes only and is not suited for a real application.
If you need to use a login form you should consider to use component org.apache.wicket.authroles.authentication.panel.SignInPanel shipped with Wicket.
</blockquote><p class="paragraph"/>This form needs two text fields, one of which must be a password field. We should also use a label to display the result of login process1. For the sake of simplicity, the login logic is all inside onSubmit and is quite trivial.<p class="paragraph"/>The following is a possible implementation of our form:<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">public</span> class LoginForm <span class="java&#45;keyword">extends</span> Form &#123;<p class="paragraph"/>	<span class="java&#45;keyword">private</span> TextField usernameField;
	<span class="java&#45;keyword">private</span> PasswordTextField passwordField;
	<span class="java&#45;keyword">private</span> Label loginStatus;<p class="paragraph"/>	<span class="java&#45;keyword">public</span> LoginForm(<span class="java&#45;object">String</span> id) &#123;
		<span class="java&#45;keyword">super</span>(id);<p class="paragraph"/>		usernameField = <span class="java&#45;keyword">new</span> TextField(<span class="java&#45;quote">"username"</span>, Model.of(<span class="java&#45;quote">""</span>));
		passwordField = <span class="java&#45;keyword">new</span> PasswordTextField(<span class="java&#45;quote">"password"</span>, Model.of(<span class="java&#45;quote">""</span>));			
		loginStatus = <span class="java&#45;keyword">new</span> Label(<span class="java&#45;quote">"loginStatus"</span>, Model.of(<span class="java&#45;quote">""</span>));<p class="paragraph"/>		add(usernameField);
		add(passwordField);
		add(loginStatus);
	&#125;<p class="paragraph"/>	<span class="java&#45;keyword">public</span> <span class="java&#45;keyword">final</span> void onSubmit() &#123;
		<span class="java&#45;object">String</span> username = (<span class="java&#45;object">String</span>)usernameField.getDefaultModelObject();
		<span class="java&#45;object">String</span> password = (<span class="java&#45;object">String</span>)passwordField.getDefaultModelObject();<p class="paragraph"/>		<span class="java&#45;keyword">if</span>(username.equals(<span class="java&#45;quote">"test"</span>) &#38;&#38; password.equals(<span class="java&#45;quote">"test"</span>))
			loginStatus.setDefaultModelObject(<span class="java&#45;quote">"Congratulations!"</span>);
		<span class="java&#45;keyword">else</span>
			loginStatus.setDefaultModelObject(<span class="java&#45;quote">"Wrong username or password!"</span>);			
	&#125;
&#125;</pre></div><p class="paragraph"/>Inside form's constructor we build the three components used in the form and we assign them a model containing an empty string:<p class="paragraph"/><div class="code"><pre>usernameField = <span class="java&#45;keyword">new</span> TextField(<span class="java&#45;quote">"username"</span>, Model.of(<span class="java&#45;quote">""</span>));
passwordField = <span class="java&#45;keyword">new</span> PasswordTextField(<span class="java&#45;quote">"password"</span>, Model.of(<span class="java&#45;quote">""</span>));			
loginStatus = <span class="java&#45;keyword">new</span> Label(<span class="java&#45;quote">"loginStatus"</span>, Model.of(<span class="java&#45;quote">""</span>));</pre></div><p class="paragraph"/>If we don't provide a model to a form component, we will get the following exception on form submission:<p class="paragraph"/><div class="code"><pre>java.lang.IllegalStateException: Attempt to set model object on <span class="java&#45;keyword">null</span> model of component:</pre></div><p class="paragraph"/>Component TextField corresponds to the standard text field, without any particular behavior or restriction on the allowed values. We must bind this component to the &#60;input&#62; tag with the attribute type set to "text". PasswordTextField is a subtype of TextFiled and it must be used with an &#60;input&#62; tag with the attribute type set to"password". For security reasons component PasswordTextField cleans its value at each request, so it wil be always empty after the form has been rendered. By default PasswordTextField fields are required, meaning that if we left them empty, the form won't be submitted (i.e. onSubmit won't be called). Class FormComponent provides method setRequired(boolean required) to change this behavior. Inside onSubmit, to get/set model objects we have used shortcut methods setDefaultModelObject and getDefaultModelObject. Both methods are defined in class Component (see class diagram from Illustration 9.1).<p class="paragraph"/>The following are the possible markup and code for the login page:<p class="paragraph"/>Html:<p class="paragraph"/><div class="code"><pre>&#60;html&#62;
	&#60;head&#62;
  		&#60;title&#62;Login page&#60;/title&#62;
	&#60;/head&#62;
	&#60;body&#62;
		&#60;form id=<span class="java&#45;quote">"loginForm"</span> method=<span class="java&#45;quote">"get"</span> wicket:id=<span class="java&#45;quote">"loginForm"</span>&#62;
  			&#60;fieldset&#62;
    			&#60;legend style=<span class="java&#45;quote">"color: &#35;F90"</span>&#62;Login&#60;/legend&#62;
    				&#60;p wicket:id=<span class="java&#45;quote">"loginStatus"</span>&#62;&#60;/p&#62;
    				&#60;span&#62;Username: &#60;/span&#62;&#60;input wicket:id=<span class="java&#45;quote">"username"</span> type=<span class="java&#45;quote">"text"</span> id=<span class="java&#45;quote">"username"</span> /&#62;&#60;br/&#62;
    				&#60;span&#62;Password: &#60;/span&#62;&#60;input wicket:id=<span class="java&#45;quote">"password"</span> type=<span class="java&#45;quote">"password"</span> id=<span class="java&#45;quote">"password"</span> /&#62;
    				&#60;p&#62;
    					&#60;input type=<span class="java&#45;quote">"submit"</span> name=<span class="java&#45;quote">"Login"</span> value=<span class="java&#45;quote">"Login"</span>/&#62;
    				&#60;/p&#62;
  	   	    &#60;/fieldset&#62;
		&#60;/form&#62;
	&#60;/body&#62;
&#60;/html&#62;</pre></div><p class="paragraph"/>Java code:<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">public</span> class HomePage <span class="java&#45;keyword">extends</span> WebPage &#123;<p class="paragraph"/>   <span class="java&#45;keyword">public</span> HomePage(<span class="java&#45;keyword">final</span> PageParameters parameters) &#123;<p class="paragraph"/>		<span class="java&#45;keyword">super</span>(parameters);
    	add(<span class="java&#45;keyword">new</span> LoginForm(<span class="java&#45;quote">"loginForm"</span>));<p class="paragraph"/>    &#125;
&#125;</pre></div><p class="paragraph"/>The example shows how Wicket form components can be used to store user input inside their model. However we can dramatically improve the form code using CompoundPropertyModel and its ability to access the properties of its model object. The revisited code is the following (the LoginFormRevisited project):<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">public</span> class LoginForm <span class="java&#45;keyword">extends</span> Form&#123;<p class="paragraph"/>		<span class="java&#45;keyword">private</span> <span class="java&#45;object">String</span> username;
		<span class="java&#45;keyword">private</span> <span class="java&#45;object">String</span> password;
		<span class="java&#45;keyword">private</span> <span class="java&#45;object">String</span> loginStatus;<p class="paragraph"/>		<span class="java&#45;keyword">public</span> LoginForm(<span class="java&#45;object">String</span> id) &#123;
			<span class="java&#45;keyword">super</span>(id);			
			setDefaultModel(<span class="java&#45;keyword">new</span> CompoundPropertyModel(<span class="java&#45;keyword">this</span>));<p class="paragraph"/>			add(<span class="java&#45;keyword">new</span> TextField(<span class="java&#45;quote">"username"</span>));
			add(<span class="java&#45;keyword">new</span> PasswordTextField(<span class="java&#45;quote">"password"</span>));
			add(<span class="java&#45;keyword">new</span> Label(<span class="java&#45;quote">"loginStatus"</span>));
		&#125;<p class="paragraph"/>		<span class="java&#45;keyword">public</span> <span class="java&#45;keyword">final</span> void onSubmit() &#123;			
			<span class="java&#45;keyword">if</span>(username.equals(<span class="java&#45;quote">"test"</span>) &#38;&#38; password.equals(<span class="java&#45;quote">"test"</span>))
				loginStatus = <span class="java&#45;quote">"Congratulations!"</span>;
			<span class="java&#45;keyword">else</span>
				loginStatus = <span class="java&#45;quote">"Wrong username or password !"</span>;			
		&#125;
	&#125;</pre></div><p class="paragraph"/>In this version the form itself is used as model object for its CompoundPropertyModel. This allows children components to have direct access to form fields and use them as backing objects, without explicitly creating a model for themselves.<p class="paragraph"/><blockquote class="note">
Keep in mind that when CompoundPropertyModel is inherited, it does not consider the ids of traversed containers for the final property expression, but it will always use the id of the visited child. To understand this potential pitfall, let's consider the following initialization code of a page:<p class="paragraph"/><div class="code"><pre>//Create a person named 'John Smith'
Person person = <span class="java&#45;keyword">new</span> Person(<span class="java&#45;quote">"John"</span>, <span class="java&#45;quote">"Smith"</span>);
//Create a person named 'Jill Smith'
Person spouse = <span class="java&#45;keyword">new</span> Person(<span class="java&#45;quote">"Jill"</span>, <span class="java&#45;quote">"Smith"</span>);
//Set Jill as John's spouse
person.setSpouse(spouse);<p class="paragraph"/>setDefaultModel(<span class="java&#45;keyword">new</span> CompoundPropertyModel(person));
WebMarkupContainer spouse = <span class="java&#45;keyword">new</span> WebMarkupContainer(<span class="java&#45;quote">"spouse"</span>);
Label name;
spouse.add(name = <span class="java&#45;keyword">new</span> Label(<span class="java&#45;quote">"name"</span>));<p class="paragraph"/>add(spouse);</pre></div><p class="paragraph"/>The value displayed by label "name" will be "John" and not the spouse's name  "Jill" as you may expect. In this example the label doesn't own a model, so it must search up its container hierarchy for an inheritable model. However, its container (WebMarkup Container with id 'spouse') doesn't own a model, hence the request for a model is forwarded to the parent container, which in this case is the page. In the end the label inherits CompoundPropertyModel from page but only its own id is used for the property expression. The containers in between are never taken into account for the final property expression.
</blockquote>


<h2 id="chapter10_4">10.4 Component DropDownChoice</h2>
<p class="paragraph"/>Class org.apache.wicket.markup.html.form.DropDownChoice is the form component needed to display a list of possible options as a drop-down list where users can select one of the proposed options. This component must be used with &#60;select&#62; tag:<p class="paragraph"/>Html:<p class="paragraph"/><div class="code"><pre>&#60;form wicket:id=<span class="java&#45;quote">"form"</span>&#62;
	Select a fruit: &#60;select wicket:id=<span class="java&#45;quote">"fruits"</span>&#62;&#60;/select&#62;
&#60;div&#62;&#60;input type=<span class="java&#45;quote">"submit"</span> value=<span class="java&#45;quote">"submit"</span>/&#62;&#60;/div&#62;
&#60;/form&#62;</pre></div><p class="paragraph"/>Java code:<p class="paragraph"/><div class="code"><pre>List&#60;<span class="java&#45;object">String</span>&#62; fruits = Arrays.asList(<span class="java&#45;quote">"apple"</span>, <span class="java&#45;quote">"strawberry"</span>, <span class="java&#45;quote">"watermelon"</span>); 
form.add(<span class="java&#45;keyword">new</span> DropDownChoice&#60;<span class="java&#45;object">String</span>&#62;(<span class="java&#45;quote">"fruits"</span>, <span class="java&#45;keyword">new</span> Model(), fruits));</pre></div><p class="paragraph"/>Screenshot of generated page:<p class="paragraph"/><img border="0" class="center" src="../img/dropdown-choice.png"></img><p class="paragraph"/>In addition to the component id, in order to build a DropDownChoice we need to provide to its constructor two further parameters:
<ul class="star">
<li>a model containing the current selected item. This parameter is not required if we are going to inherit a CompoundPropertyModel for this component.</li>
<li>a list of options to display which can be supplied as a model or as a regular java.util.List.</li>
</ul><p class="paragraph"/>In the example above the possible options are provided as a list of String objects. Now let's take a look at the markup generated for them:<p class="paragraph"/><div class="code"><pre>&#60;select name=<span class="java&#45;quote">"fruits"</span> wicket:id=<span class="java&#45;quote">"fruits"</span>&#62;
	&#60;option value=<span class="java&#45;quote">""</span> selected=<span class="java&#45;quote">"selected"</span>&#62;Choose One&#60;/option&#62;
	&#60;option value=<span class="java&#45;quote">"0"</span>&#62;apple&#60;/option&#62;
	&#60;option value=<span class="java&#45;quote">"1"</span>&#62;strawberry&#60;/option&#62;
	&#60;option value=<span class="java&#45;quote">"2"</span>&#62;watermelon&#60;/option&#62;
&#60;/select&#62;</pre></div><p class="paragraph"/>The first option is a placeholder item corresponding to a null model value. By default DropDownChoice cannot have a null value so users are forced to select a not-null option. If we want to change this behavior we can set the nullValid flag to true via the setNullValid method. Please note that the placeholder text (“Chose one”) can be localized, as we will see in chapter 12. The other options are identified by the attribute value. By default the value of this attribute is the index of the single option inside the provided list of choices, while the text displayed to the user is obtained by  calling toString()on the choice object. This default behavior works fine as long as our options are simple objects like strings, but when we move to more complex objects we may need to implement a more sophisticated algorithm to generate the value to use as the option id and the one to display to user. Wicket has solved this problem with org.apache.wicket.markup.html.form.IChoiceRender interface. This interface defines method getDisplayValue(T object) that is called to generate the value to display for the given choice object, and method getIdValue(T object, int index) that is called to generate the option id. The built-in implementation of this interface is class org.apache.wicket.markup.html.Form. ChoiceRenderer which renders the two values using property expressions.<p class="paragraph"/>In the following code we want to show a list of Person objects using their full name as value to display and using their passport code as option id:<p class="paragraph"/>Java code:<p class="paragraph"/><div class="code"><pre>List&#60;Person&#62; persons; 
//Initialize the list of persons here&#8230;
ChoiceRenderer personRenderer = <span class="java&#45;keyword">new</span> ChoiceRenderer(<span class="java&#45;quote">"fullName"</span>, <span class="java&#45;quote">"passportCode"</span>);
form.add(<span class="java&#45;keyword">new</span> DropDownChoice&#60;<span class="java&#45;object">String</span>&#62;(<span class="java&#45;quote">"persons"</span>, <span class="java&#45;keyword">new</span> Model&#60;Person&#62;(), persons, personRenderer));</pre></div><p class="paragraph"/>The choice renderer can be assigned to the DropDownChoice using one of its constructor that accepts this type of parameter (like we did in the example above) or after its creation invoking setChoiceRenderer method.


<h2 id="chapter10_5">10.5 Model chaining</h2>
<p class="paragraph"/>Models that implement the interface org.apache.wicket.model.IChainingModel can be used to build a chain of models. These kinds of models are able to recognize whether their model object is itself an implementation of IModel and if so, they will call getObject on the wrapped model and the returned value will be the actual model object. In this way we can combine the action of an arbitrary number of models, making exactly a chain of models. Chaining models allows to combine different data persistence strategies, similarly to what we do with chains of <a href="http://java.sun.com/developer/technicalArticles/Streams/ProgIOStreams" target="blank">I/O streams.</a> To see model chaining in action we will build a page that implements the List/Detail View pattern, where we have a drop-down list of Person objects and a form to display and edit the data of the current selected Person.<p class="paragraph"/>The example page will look like this:<p class="paragraph"/><img border="0" class="center" src="../img/model-chaining.png"></img><p class="paragraph"/>What we want to do in this example is to chain the model of the DropDownChoice (which contains the selected Person) with the model of the Form. In this way the Form will work with the selected Person as backing object. The DropDownChoice component can be configured to automatically update its model each time we change the selected item on the client side. All we have to do is to override method wantOn SelectionChangedNotifications to make it return true. In practice, when this method returns true, DropDownChoice will submit its value every time JavaScript event onChange occurs, and its model will be consequently updated. To leverage this functionality, DropDownChoice doesn't need to be inside a form.<p class="paragraph"/>The following is the resulting markup of the example page:<p class="paragraph"/><div class="code"><pre>&#8230;
&#60;body&#62;
	List of persons &#60;select wicket:id=<span class="java&#45;quote">"persons"</span>&#62;&#60;/select&#62; &#60;br/&#62;
	&#60;br/&#62;
	&#60;form wicket:id=<span class="java&#45;quote">"form"</span>&#62;		
		&#60;div style=<span class="java&#45;quote">"display: table;"</span>&#62;
			&#60;div style=<span class="java&#45;quote">"display: table&#45;row;"</span>&#62;
				&#60;div style=<span class="java&#45;quote">"display: table&#45;cell;"</span>&#62;Name: &#60;/div&#62;
				&#60;div style=<span class="java&#45;quote">"display: table&#45;cell;"</span>&#62;
					&#60;input type=<span class="java&#45;quote">"text"</span> wicket:id=<span class="java&#45;quote">"name"</span>/&#62; 
				&#60;/div&#62;	
			&#60;/div&#62;
			&#60;div style=<span class="java&#45;quote">"display: table&#45;row;"</span>&#62;
				&#60;div style=<span class="java&#45;quote">"display: table&#45;cell;"</span>&#62;Surname: &#60;/div&#62;
				&#60;div style=<span class="java&#45;quote">"display: table&#45;cell;"</span>&#62;
									&#60;input type=<span class="java&#45;quote">"text"</span> wicket:id=<span class="java&#45;quote">"surname"</span>/&#62;
								&#60;/div&#62;	
							&#60;/div&#62;
							&#60;div style=<span class="java&#45;quote">"display: table&#45;row;"</span>&#62;
								&#60;div style=<span class="java&#45;quote">"display: table&#45;cell;"</span>&#62;Address: &#60;/div&#62;
								&#60;div style=<span class="java&#45;quote">"display: table&#45;cell;"</span>&#62;
									&#60;input type=<span class="java&#45;quote">"text"</span> wicket:id=<span class="java&#45;quote">"address"</span>/&#62;
								&#60;/div&#62;	
							&#60;/div&#62;
							&#60;div style=<span class="java&#45;quote">"display: table&#45;row;"</span>&#62;
								&#60;div style=<span class="java&#45;quote">"display: table&#45;cell;"</span>&#62;Email: &#60;/div&#62;
								&#60;div style=<span class="java&#45;quote">"display: table&#45;cell;"</span>&#62;
									&#60;input type=<span class="java&#45;quote">"text"</span> wicket:id=<span class="java&#45;quote">"email"</span>/&#62;
								&#60;/div&#62;
							&#60;/div&#62;
						&#60;/div&#62;	
						&#60;input type=<span class="java&#45;quote">"submit"</span> value=<span class="java&#45;quote">"Save"</span>/&#62;
					&#60;/form&#62;
				&#60;/body&#62;</pre></div><p class="paragraph"/>The initialization code for DropDownChoice is the following:<p class="paragraph"/><div class="code"><pre>Model&#60;Person&#62; listModel = <span class="java&#45;keyword">new</span> Model&#60;Person&#62;();
ChoiceRenderer&#60;Person&#62; personRender = <span class="java&#45;keyword">new</span> ChoiceRenderer&#60;Person&#62;(<span class="java&#45;quote">"fullName"</span>);
personsList = <span class="java&#45;keyword">new</span> DropDownChoice&#60;Person&#62;(<span class="java&#45;quote">"persons"</span>, listModel, loadPersons(), personRender)&#123;<p class="paragraph"/>		@Override
		<span class="java&#45;keyword">protected</span> <span class="java&#45;object">boolean</span> wantOnSelectionChangedNotifications() &#123;
			<span class="java&#45;keyword">return</span> <span class="java&#45;keyword">true</span>;
		&#125;<p class="paragraph"/>&#125;;</pre></div><p class="paragraph"/>As choice render we have used the basic implementation provided with the org.apache.wicket .markup.html.form.ChoiceRenderer class that we have seen in the previous paragraph. loadPersons() is just an utility method which generates a list of Person instances. The model for DropDownChoice is a simple instance of the Model class.<p class="paragraph"/>Here is the whole code of the page (except for the loadPersons() method):<p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">public</span> class PersonListDetails <span class="java&#45;keyword">extends</span> WebPage &#123;
  <span class="java&#45;keyword">private</span> Form form;
  <span class="java&#45;keyword">private</span> DropDownChoice&#60;Person&#62; personsList;<p class="paragraph"/>  <span class="java&#45;keyword">public</span> PersonListDetails()&#123;
    Model&#60;Person&#62; listModel = <span class="java&#45;keyword">new</span> Model&#60;Person&#62;();
    ChoiceRenderer&#60;Person&#62; personRender = <span class="java&#45;keyword">new</span> ChoiceRenderer&#60;Person&#62;(<span class="java&#45;quote">"fullName"</span>);<p class="paragraph"/>    personsList = <span class="java&#45;keyword">new</span> DropDownChoice&#60;Person&#62;(<span class="java&#45;quote">"persons"</span>, listModel, loadPersons(),
                                                         personRender)&#123;
      @Override
      <span class="java&#45;keyword">protected</span> <span class="java&#45;object">boolean</span> wantOnSelectionChangedNotifications() &#123;
        <span class="java&#45;keyword">return</span> <span class="java&#45;keyword">true</span>;
      &#125;
	    &#125;;<p class="paragraph"/>	    add(personsList);<p class="paragraph"/>	    form = <span class="java&#45;keyword">new</span> Form(<span class="java&#45;quote">"form"</span>, <span class="java&#45;keyword">new</span> CompoundPropertyModel&#60;Person&#62;(listModel));    
	    form.add(<span class="java&#45;keyword">new</span> TextField(<span class="java&#45;quote">"name"</span>));
	    form.add(<span class="java&#45;keyword">new</span> TextField(<span class="java&#45;quote">"surname"</span>));
	    form.add(<span class="java&#45;keyword">new</span> TextField(<span class="java&#45;quote">"address"</span>));
	    form.add(<span class="java&#45;keyword">new</span> TextField(<span class="java&#45;quote">"email"</span>));<p class="paragraph"/>	    add(form);
	  &#125;
	       //loadPersons()
	       //&#8230;
	&#125;</pre></div><p class="paragraph"/>The two models work together as a pipeline where the output of method getObject of Model is the model object of CompoundPropertyModel. As we have seen, model chaining allows us to combine the actions of two or more models without creating new custom implementations.


<h2 id="chapter10_6">10.6 Detachable models</h2>
<p class="paragraph"/>In chapter 6 we have seen how Wicket uses serialization to store page instances. When an object is serialized, all its referenced objects are recursively serialized. For a page this means that all its children components, their related models as well as the model objects inside them will be serialized. 
For model objects this could be a serious issue for (at least) two main reasons:
<ol>
<li>The model object could be a very large instance, hence serialization would become very expensive in terms of time and memory.</li>
<li>We simply may not be able to use a serializable object as model object. In paragraphs 1.4 and 9.2 we stated that Wicket allows us to use a POJO as backing object, but <a href="http://en.wikipedia.org/wiki/Plain_Old_Java_Object#Definition" target="blank">POJOs</a> are ordinary objects with no prespecified interface, annotation or superclass, hence they are not required to implement the standard Serializable interface.</li>
</ol><p class="paragraph"/>To cope with these problems IModel extends another interface called IDetachable.<p class="paragraph"/><img border="0" class="center" src="../img/detachable-models.png"></img><p class="paragraph"/>This interface provides a method called detach() which is invoked by Wicket at the end of web request processing when data model is no more needed but before serialization occurs. Overriding this method we can clean any reference to data object keeping just the information needed to retrieve it later (for example the id of the table row where our data are stored). In this way we can avoid the serialization of the object wrapped into the model overcoming both the problem with non-serializable objects and the one with large data objects.<p class="paragraph"/>Since IModel inherits from IDetachable, every model of Wicket is “detachable”, although not all of them implement a detaching policy (like the Model class). 
Usually detaching operations are strictly dependent on the persistence technology adopted for model objects (like a relational db, a NoSQL db, a queue, etc), so it's not unusual to write a custom detachable model suited for the persistence technology chosen for a given project. To ease this task Wicket provides abstract model LoadableDetachableModel. This class internally holds a transient reference to a model object which is initialized the first time getObject()is called to precess a request. The concrete data loading is delegated to abstract method T load(). The reference to a model object is automatically set to null at the end of the request by the detach() method.<p class="paragraph"/>The following class diagram summarizes the methods defined inside LoadableDetachableModel.<p class="paragraph"/><img border="0" class="center" src="../img/loadable-detachable-model.png"></img><p class="paragraph"/>onDetach and onAttach can be overridden in order to obtain further control over the detaching procedure.<p class="paragraph"/>Now as example of a possible use of LoadableDetachableModel, we will build a model designed to work with entities managed via <a href="http://en.wikipedia.org/wiki/Java_Persistence_API" target="blank">JPA.</a> To understand the following code a basic knowledge of JPA is required even if we won't go into the detail of this standard.<p class="paragraph"/><blockquote class="warning">
The following model is provided for example purposes only and is not intended to be used in production environment. Important aspects such as transaction management are not taken into account and you should rework the code before considering to use it.
</blockquote><p class="paragraph"/><div class="code"><pre><span class="java&#45;keyword">public</span> class JpaLoadableModel&#60;T&#62; <span class="java&#45;keyword">extends</span> LoadableDetachableModel&#60;T&#62; &#123;<p class="paragraph"/>  <span class="java&#45;keyword">private</span> EntityManagerFactory entityManagerFactory;
  <span class="java&#45;keyword">private</span> <span class="java&#45;object">Class</span>&#60;T&#62; entityClass;
  <span class="java&#45;keyword">private</span> Serializable identifier;
  <span class="java&#45;keyword">private</span> List&#60;<span class="java&#45;object">Object</span>&#62; constructorParams;<p class="paragraph"/>  <span class="java&#45;keyword">public</span> JpaLoadableModel(EntityManagerFactory entityManagerFactory, T entity) &#123;<p class="paragraph"/>	<span class="java&#45;keyword">super</span>();<p class="paragraph"/>	PersistenceUnitUtil util = entityManagerFactory.getPersistenceUnitUtil();<p class="paragraph"/>		<span class="java&#45;keyword">this</span>.entityManagerFactory = entityManagerFactory;
	    <span class="java&#45;keyword">this</span>.entityClass = (<span class="java&#45;object">Class</span>&#60;T&#62;) entity.getClass();
	    <span class="java&#45;keyword">this</span>.identifier = (Serializable) util.getIdentifier(entity);<p class="paragraph"/>	    setObject(entity);
	&#125;<p class="paragraph"/>	@Override
	<span class="java&#45;keyword">protected</span> T load() &#123;
	   T entity = <span class="java&#45;keyword">null</span>;<p class="paragraph"/>	   <span class="java&#45;keyword">if</span>(identifier != <span class="java&#45;keyword">null</span>) &#123;  
	       EntityManager entityManager = entityManagerFactory.createEntityManager();
	       entity = entityManager.find(entityClass, identifier);
	     &#125;
	     <span class="java&#45;keyword">return</span> entity;
	   &#125;<p class="paragraph"/>	@Override
	<span class="java&#45;keyword">protected</span> void onDetach() &#123;
	   <span class="java&#45;keyword">super</span>.onDetach();<p class="paragraph"/>	     T entity = getObject();
	     PersistenceUnitUtil persistenceUtil = entityManagerFactory.getPersistenceUnitUtil();<p class="paragraph"/>	     <span class="java&#45;keyword">if</span>(entity == <span class="java&#45;keyword">null</span>) <span class="java&#45;keyword">return</span>;<p class="paragraph"/>	     identifier = (Serializable) persistenceUtil.getIdentifier(entity);    
	  &#125;
	&#125;</pre></div><p class="paragraph"/>The constructor of the model takes as input two parameters: an implementation of the JPA interface  javax.persistence.EntityManagerFactory to manage JPA entities and the entity that must be handled by this model. Inside its constructor the model saves the class of the entity and its id (which could be null if the entity has not been persisted yet). These two informations are required to retrieve the entity at a later time and are used by the load method.<p class="paragraph"/>onDetach is responsible for updating the entity id before detachment occurs. The id can change the first time an entity is persisted (JPA generates a new id and assigns it to the entity). Please note that this model is not responsible for saving any changes occurred to the entity object before it is detached. If we don't want to loose these changes we must explicitly persist the entity before the detaching phase occurs.<p class="paragraph"/><blockquote class="warning">
Since the model of this example holds a reference to the EntityManager Factory, the implementation in use must be serializable.
</blockquote>


<h2 id="chapter10_7">10.7 Using more than one model in a component</h2>
<p class="paragraph"/>Sometimes our custom components may need to use more than a single model to work properly. In such a case we must manually detach the additional models used by our components. In order to do this we can overwrite the Component's onDetach method that is called at the end of the current request. The following is the generic code of a component that uses two models:<p class="paragraph"/><div class="code"><pre>/&#42;&#42;
 &#42; 
 &#42; fooModel is used as main model <span class="java&#45;keyword">while</span> beeModel must be manually detached
 &#42;
 &#42;/
<span class="java&#45;keyword">public</span> class ComponetTwoModels <span class="java&#45;keyword">extends</span> Component&#123;<p class="paragraph"/>	<span class="java&#45;keyword">private</span> IModel&#60;Bee&#62; beeModel;<p class="paragraph"/>	<span class="java&#45;keyword">public</span> ComponetTwoModels(<span class="java&#45;object">String</span> id, IModel&#60;Foo&#62; fooModel, IModel&#60;Bee&#62; beeModel) &#123;
		<span class="java&#45;keyword">super</span>(id, fooModel);
		<span class="java&#45;keyword">this</span>.beeModel = beeModel;
	&#125;<p class="paragraph"/>	@Override
	<span class="java&#45;keyword">public</span> void onDetach() &#123;
               <span class="java&#45;keyword">if</span>(beeModel != <span class="java&#45;keyword">null</span>)
	   beeModel.detach();<p class="paragraph"/>              <span class="java&#45;keyword">super</span>.onDetach();
	&#125;
&#125;</pre></div><p class="paragraph"/>When we overwrite onDetach we must call the super class implementation of this method, usually as last line in our custom implementation.


<h2 id="chapter10_8">10.8 Use models!</h2>
<p class="paragraph"/>Like many people new to Wicket, you may need a little time to fully understand the power and the advantages of using models. Taking your first steps with Wicket you may be tempted to pass row objects to your components instead of using models:<p class="paragraph"/><div class="code"><pre>/&#42;&#42;
 &#42; 
 &#42; NOT TO DO: passing row objects to components instead of using models!
 &#42;
 &#42;/
<span class="java&#45;keyword">public</span> class CustomComponent <span class="java&#45;keyword">extends</span> Component&#123;
	<span class="java&#45;keyword">private</span> FooBean fooBean;<p class="paragraph"/>	<span class="java&#45;keyword">public</span> CustomComponent(<span class="java&#45;object">String</span> id, FooBean fooBean) &#123;
		<span class="java&#45;keyword">super</span>(id);
		<span class="java&#45;keyword">this</span>.fooBean = fooBean;
	&#125;
	//...some other ugly code :)&#8230;
&#125;</pre></div><p class="paragraph"/>That's a bad practice and you must avoid it. Using models we do not only decouple our components from the data source, but we can also relay on them (if they are dynamic) to work with the most up-to-date version of our model object. If we decide to bypass models we lose all these advantages and we force model objects to be serialized.


<h2 id="chapter10_9">10.9 Summary</h2>
<p class="paragraph"/>Models are at the core of Wicket and they are the basic ingredient needed to taste the real power of the framework. In this chapter we have seen how to use models to bring data to our components without littering their code with technical details about their persistence strategy.
We have also introduced Wicket forms as complementary topic. With forms and models we are able to bring our applications to life allowing them to interact with users. But what we have seen in this chapter about Wicket forms is just the tip of the iceberg. That's why the next chapter is entirely dedicated to them.


                <div style="clear:both;margin-top:15px;"></div>
                
                    <div class="toc-item prev-left"><a href="../guide/chapter9.html">&lt;&lt; <strong>9</strong><span>Wicket Links and URL generation</span></a></div>
                
                    <div class="toc-item next-right"><a href="../guide/chapter11.html"><strong>11</strong><span>Wicket forms in detail</span> >></a></div>
                
                <div style="clear:both"></div>
            </div>
        </td>
        <td id="col2">
            <div class="local clearfix">
                <div class="local-title">
                    <a href="../guide/index.html" target="mainFrame">Quick Reference</a>
                    <span class="toggle">(<a href="#" onclick="localToggle(); return false;">hide</a>)</span>
                </div>
                <div class="menu">
                    
                </div>
            </div>
        </td>
    </tr>
</table>

<div id="footer">
    
Copyright &copy; 2013 — <a href="http://www.comsysto.com" target="_blank">comSysto GmbH</a>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-43124634-1', 'comsysto.com');
  ga('send', 'pageview');

</script>

    
</div>

<script type="text/javascript" src="../js/docs.js"></script>

</body>
</html>
